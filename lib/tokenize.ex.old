defmodule ExCss.Tokenizer do
  # write css tokenizer that from 1 method call with some state returns the next token it encounters
  # then we can create TokenStream.consume(state), TokenStream.peek(state, 2), etc.

  def execute(str) do
    state = %{str: str, pos: -1, line: 0, column: 0, last_line_length: 0}

    consume_a_token(state)
  end

  def consume_a_token(state) do
    state
    |> consume_comments
    |> consume
    |> consume_whitespace
  end

  defp consume_something(state = %{char: "\""}), do: consume_a_string(state)

  defp consume_whitespace(state), do: consume_whitespace(state, false)
  defp consume_whitespace(state, ignore_token) do
    if whitespace?(state) do
    	state = state
      |> consume
      |> consume_whitespace(false)
      |> found_token({:whitespace}, ignore_token)
    else
      state
    end
  end

  defp consume_comments(state), do: consume_comments(state, next(state, 1), next(state, 2))
  defp consume_comments(state, "\\", "*") do
    state
    |> consume(2)
    |> consume_until_comment_closes
  end

  defp consume_until_comment_closes(state) do
    state = %{char: char} = state
    |> consume

    if char == "*" && next(state, 1) == "/" do
      state
    else
      if eof?(char) do
        throw "End of file reached while consuming a comment"
      else
        consume_until_comment_closes(state)
      end
    end
  end

  defp found_token(state, token, false), do: throw {state, :token, token}
  defp found_token(state, token, true), do: nil

  defp next(state), do: next(state, 1)
  defp next(%{str: str, pos: pos}, num) do
		if num > 3 do
			throw "Spec Error: no more than three codepoints of lookahead."
    end

		String.at(str, pos + num)
  end

  defp consume(state = %{str: str, pos: pos, line: line, column: column}) do
    char = String.at(str, pos + 1)

    state = if new_line?(char) do
      increment_line(state)
    else
      increment_column(state, 1)
    end

    state
    |> Map.merge(%{pos: pos + 1, char: char})
  end
  defp consume(state, num) do
    consume(state)
    consume(state, num - 1)
  end
  defp consume(state, 0), do: nil

  defp reconsume(state = %{pos: pos, line: line, column: column, char: char}) do
		state = if new_line?(char) do
      decrement_line(state)
		else
			decrement_column(state)
    end
  end

  defp increment_line(state = %{line: line, column: column}) do
    state
    |> Map.merge(%{line: line + 1, column: 0, last_line_length: column})
  end

  defp decrement_line(state = %{line: line, column: column, last_line_length: last_line_length}) do
    state
    |> Map.merge(%{line: line - 1, column: last_line_length, last_line_length: "unknown"})
  end

  defp increment_column(state = %{line: line, column: column}, num) do
    state
    |> Map.merge(%{column: column + num})
  end

  defp decrement_column(state = %{column: column}) do
    state
    |> Map.merge(%{column: column - 1})
  end

  defp whitespace?(char), do: new_line?(char) || code == "\t" || code == " "
  defp new_line?(char), do: char == "\n"
  defp eof?(char), do: char == nil
end
